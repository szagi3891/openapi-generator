import { EndpointSpecType, JSONValue } from '../type.ts';
import { renderParamsTypeZod } from './renderParams.ts';
import { renderResponse } from './renderResponse.ts';
import { renderType } from './renderType.ts';
import { toBigCamelCase, wordFirstLetterToLower } from './toBigCamelCase.ts';
import { renderResponseGeneric } from './renderResponseGeneric.ts';
import { generateUrlAll } from './generateUrlAll.ts';
import { renderImports } from './renderModels.ts';

const getBody = (spec: EndpointSpecType): string => {
    for (const param of spec.parameters) {
        if (param.in === 'body') {
            const name = param.name;
            return `params.${name}`;
        }
    }

    return 'undefined';
};

const generateHeadersType = (parameters: EndpointSpecType['parameters']): string => {
    const left = '{';
    const right = '}';

    const headers: string[] = [];

    const typeParam = 'type ExtraHeadersType = z.TypeOf<typeof ExtraHeadersZod>;';

    for (const param of parameters) {
        if (param.in === 'header') {
            const name = param.name;
            const paramType = renderType(4, param.schema);
            if (name.includes('-')) {
                headers.push(`    '${name}': ${paramType},`);
            } else {
                headers.push(`    ${name}: ${paramType},`);
            }
        }
    }

    if (headers.length > 0) {
        const headersJoin = headers.join('\n');
        return `const ExtraHeadersZod = z.object(${left}\n${headersJoin}\n${right});\n${typeParam}\n`;
    }

    return `const ExtraHeadersZod = z.record(z.string(), z.string());\n${typeParam}\n`;
};

const generateHeadersParam = (parameters: EndpointSpecType['parameters']): string => {

    let counter = 0;

    for (const param of parameters) {
        if (param.in === 'header') {
            counter += 1;
        }
    }

    if (counter > 0) {
        return 'extraHeaders: ExtraHeadersType';
    }

    return 'extraHeaders?: ExtraHeadersType';
};

export const renderEndpoint = (openApiSpec: JSONValue, nameInFile: string, method: string, url: string, handler: EndpointSpecType): string => {
    const left = '{';
    const right = '}';

    const imports = renderImports(openApiSpec, handler);
    const generateParamsDef = renderParamsTypeZod(handler);
    const generateResponseIoData = renderResponse(handler, url, method);
    const generateMethod = method;
    const generateBody = getBody(handler);
    const extraHeadersType = generateHeadersType(handler.parameters);
    const extra_headers = generateHeadersParam(handler.parameters);

    const nameInFileCamelcaseBig = toBigCamelCase(nameInFile);
    const nameInFileCamelcaseSmall = wordFirstLetterToLower(nameInFileCamelcaseBig);
    const [genericResponseTypes, genericResponseIfs] = renderResponseGeneric(
        nameInFileCamelcaseBig,
        handler
    );
    // const queryStringParams = queryStringParams(handler.parameters);
    const urlCode = generateUrlAll(url, handler);

    const content = `//The contents of this file have been generated automatically. Do not edit this file.

import { z } from 'zod';
${imports}

${generateParamsDef}

${generateResponseIoData}

${extraHeadersType}

export type ${nameInFileCamelcaseBig}ParamsType = ParamsType;

${genericResponseTypes}

const convertHeaders = (params: Record<string, string | null | undefined>): Record<string, string> => ${left}
    const result: Record<string, string> = ${left}${right};

    for (const [name, value] of Object.entries(params)) ${left}
        if (value !== null && value !== undefined) ${left}
            result[name] = value;
        ${right}
    ${right}

    return result;
${right};

export const ${nameInFileCamelcaseSmall}Request = async (
    api_url: string,
    params: ParamsType,
    ${extra_headers}
): Promise<${nameInFileCamelcaseBig}ResponseType> => ${left}
    const ok = ParamsTypeZOD.safeParse(params);
    if (!ok.success) ${left}
        console.error('Input parameters do not match the definition from openapi');
    ${right}

    ${urlCode}

    const headers = convertHeaders(${left}
        'Content-Type': 'application/json; charset=utf-8',
        ...extraHeaders
    ${right});

    const response = await fetch(url, ${left}
        method: '${generateMethod.toUpperCase()}',
        headers,
        body: JSON.stringify(${generateBody}),
        credentials: 'include'
    ${right});

    const status = response.status;

    let json = null;

    try ${left}
        const text = await response.text();
        if (text !== '') ${left}
            json = JSON.parse(text);
        ${right}
    ${right} catch (_err) ${left}
        throw Error(\`Http status $${left}status${right} - json was expected\`);
    ${right}
    ${genericResponseIfs}

    throw new Error(\`${nameInFileCamelcaseSmall}Request - unhandled response $${left}status${right}\`);
${right};
`;

    return content;
};

