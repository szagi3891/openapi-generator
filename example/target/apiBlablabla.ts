//The contents of this file have been generated automatically. Do not edit this file.

import { z } from 'zod';
import {
    PetsZod,
} from './schemas.ts';

export const ParamsTypeZOD = z.object({
    limit: z.number().optional(),
});
export type ParamsType = z.TypeOf<typeof ParamsTypeZOD>;

const checkResponse = <A>(code: number, decoder: z.ZodType<A>, data: unknown): A => {
    const decodeResult = decoder.safeParse(data);
    if (decodeResult.success) {
        return decodeResult.data;
    }
    console.error('error details', {
        errors: decodeResult.error.errors,
        data
    });
    throw Error(`Response decoding error /pets -> get -> ${code}`);
};


export const Response200ZOD = PetsZod;
export type Response200Type = z.TypeOf<typeof Response200ZOD>;


const ExtraHeadersZod = z.record(z.string(), z.string());
type ExtraHeadersType = z.TypeOf<typeof ExtraHeadersZod>;


export type ApiBlablablaParamsType = ParamsType;


export type ApiBlablablaResponseType = 
    {
        status: 200;
        body: Response200Type;
    };

export type ApiBlablablaResponse200Type = Response200Type;

const convertHeaders = (params: Record<string, string | null | undefined>): Record<string, string> => {
    const result: Record<string, string> = {};

    for (const [name, value] of Object.entries(params)) {
        if (value !== null && value !== undefined) {
            result[name] = value;
        }
    }

    return result;
};

export const apiBlablablaRequest = async (
    api_url: string,
    params: ParamsType,
    extraHeaders?: ExtraHeadersType
): Promise<ApiBlablablaResponseType> => {
    const ok = ParamsTypeZOD.safeParse(params);
    if (!ok.success) {
        console.error('Input parameters do not match the definition from openapi');
    }

    
        
    const query = ((): string => {
        const query: string[] = [];

        const addParam = (param: string, value: string | string[] | number | boolean | null | undefined): void => {
            if (typeof value === 'string') {
                query.push(`${param}=${encodeURIComponent(value)}`);
                return;
            }

            if (typeof value === 'number' || typeof value === 'boolean') {
                query.push(`${param}=${value.toString()}`);
                return;
            }

            if (Array.isArray(value)) {
                for (const v of value) {
                    query.push(`${param}=${encodeURIComponent(v)}`);
                }
                
                return;
            }
        };

        
        addParam('limit', params?.limit);

        return query.length > 0 ? `?${query.join('&')}` : '';
    })();
    const url = `${api_url}/pets${query}`;
    

    const headers = convertHeaders({
        'Content-Type': 'application/json; charset=utf-8',
        ...extraHeaders
    });

    const response = await fetch(url, {
        method: 'GET',
        headers,
        body: JSON.stringify(undefined),
        credentials: 'include'
    });

    const status = response.status;

    let json = null;

    try {
        const text = await response.text();
        if (text !== '') {
            json = JSON.parse(text);
        }
    } catch (_err) {
        throw Error(`Http status ${status} - json was expected`);
    }
    
    if (status === 200) {
        return { status: 200, body: checkResponse(200, Response200ZOD, json) };
    }

    throw new Error(`apiBlablablaRequest - unhandled response ${status}`);
};
